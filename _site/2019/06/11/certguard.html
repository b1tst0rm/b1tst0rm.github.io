<!DOCTYPE html>
<html lang="en-US">
  <head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130660906-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130660906-1');
</script>

    <meta charset="UTF-8">
    <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Using Facebook’s Certificate Transparency Tool to detect phishing | B1tst0rm</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Using Facebook’s Certificate Transparency Tool to detect phishing" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Using Facebook’s Certificate Transparency Tool to detect phishing Signed SSL certificates are handed out by trusted organizations for specific domains to verify to the end user that the server is who they say they are. Many browsers display a lock symbol to indicate that the content is being served over the encrypted HTTPS protocol and will not display errors or warnings if the certificate was issued legitimately (ie., not self-signed). However, anyone can acquire domains and signed SSL certificates for little-to-no-cost, including the bad guys." />
<meta property="og:description" content="Using Facebook’s Certificate Transparency Tool to detect phishing Signed SSL certificates are handed out by trusted organizations for specific domains to verify to the end user that the server is who they say they are. Many browsers display a lock symbol to indicate that the content is being served over the encrypted HTTPS protocol and will not display errors or warnings if the certificate was issued legitimately (ie., not self-signed). However, anyone can acquire domains and signed SSL certificates for little-to-no-cost, including the bad guys." />
<link rel="canonical" href="http://localhost:4000/2019/06/11/certguard.html" />
<meta property="og:url" content="http://localhost:4000/2019/06/11/certguard.html" />
<meta property="og:site_name" content="B1tst0rm" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-06-11T00:00:00-05:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"http://localhost:4000/2019/06/11/certguard.html","headline":"Using Facebook’s Certificate Transparency Tool to detect phishing","dateModified":"2019-06-11T00:00:00-05:00","datePublished":"2019-06-11T00:00:00-05:00","description":"Using Facebook’s Certificate Transparency Tool to detect phishing Signed SSL certificates are handed out by trusted organizations for specific domains to verify to the end user that the server is who they say they are. Many browsers display a lock symbol to indicate that the content is being served over the encrypted HTTPS protocol and will not display errors or warnings if the certificate was issued legitimately (ie., not self-signed). However, anyone can acquire domains and signed SSL certificates for little-to-no-cost, including the bad guys.","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/06/11/certguard.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/assets/css/style.css?v=de764e18a38e3c9826eb11b0d5f31123cc15a1e0">
  </head>
  <body>
    <a id="skip-to-content" href="#content">Skip to the content.</a>

    <header class="page-header" role="banner">
      <h1 class="project-name"><a style="color:white;" href="/">B1tst0rm</a></h1>
      <h2 class="project-tagline">the red team is watching</h2>
      <a href="/" class="btn">Home</a>
      <a href="/about" class="btn">About</a>
      <a href="/posts" class="btn">Posts</a>
    </header>

    <main id="content" class="main-content" role="main">
      <h1 id="using-facebooks-certificate-transparency-tool-to-detect-phishing">Using Facebook’s Certificate Transparency Tool to detect phishing</h1>
<p>Signed SSL certificates are handed out by trusted organizations for specific domains
to verify to the end user that the server is who they say they are. Many browsers
display a lock symbol to indicate that the content is being served over the
encrypted HTTPS protocol and will not display errors or warnings if the certificate
was issued legitimately (ie., not self-signed). However, anyone can acquire
domains and signed SSL certificates for little-to-no-cost, including the bad guys.</p>

<p>To aid in transparency and help with unapproved certificate handouts, web browsers
like Chrome are beginning to require that all certificates are placed into what is
referred to as a certificate transparency (CT) log. There are quite a few official log
locations for these certificates. These logs contain the time/date of issuance,
as well as the domain and certificate authority that issued said certificate.</p>

<p>Facebook introduced their Certificate Transparency Monitoring tool in 2016 and added
support for Webhooks in 2017. Their tool checks against numerous CT logs and can
send email, push, and webhook notifications for any domain that a user wishes to
track. In addition, and what will be the main focus of this post, the tool also
has capability to detect suspicious domains similar to a given domain that
could be used for phishing.</p>

<h2 id="phishing-domain-monitoring">Phishing Domain Monitoring</h2>
<p>Domains are human readable addresses that we implicitly, and perhaps subconciously,
place trust in. A link to download a file from <code class="highlighter-rouge">172.217.11.238</code> is much more alarming
than <code class="highlighter-rouge">drive.google.com</code>. Attackers use trusted domain names to trick and phish
victims, usually via email.</p>

<p>Attackers can perform a number of domain “tricks” to register what look almost
exactly like legitimate domains from a trusted company.</p>

<p>According to <a href="https://www.facebook.com/notes/protect-the-graph/detecting-phishing-domains-using-certificate-transparency/2037453483161459/">Facebook’s blog post</a>,
they can detect the following phishing domains:</p>

<h3 id="homograph-attacks">Homograph Attacks</h3>
<p>An attacker can register a domain that appears the same, but consists of different
unicode characters.</p>

<p>For example: <code class="highlighter-rouge">faceb00k[.]com</code>: the letter <code class="highlighter-rouge">o</code>’s in <code class="highlighter-rouge">facebook</code> are replaced by the
number zero.</p>

<p>Another example: <code class="highlighter-rouge">facebook[.]com</code>: the letter <code class="highlighter-rouge">о</code> is actually the Cyrillic small
letter <code class="highlighter-rouge">o</code> (0x43E), not the Latin <code class="highlighter-rouge">o</code> (0x6F).</p>

<h3 id="typo-squatting">Typo-squatting</h3>
<p>Similar domains that have typos can look like the real thing at first glance,
prompting victims to trust a link.</p>

<p>For example: <code class="highlighter-rouge">gooogle.com</code></p>

<h3 id="mobile-screens">Mobile Screens</h3>
<p>Mobile browsers often show only the first part of a domain in the URL bar if the
domain is too long. Therefore, an attacker can register a long domain name
and use subdomains to trick users.</p>

<p>If I registered <code class="highlighter-rouge">xxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyzzzzzzzzzz.com</code>, I can create a
DNS record for <code class="highlighter-rouge">google.com.xxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyzzzzzzzzzz.com</code> and
on some devices it is possible that only <code class="highlighter-rouge">google.com</code> would actually be displayed
in the URL bar.</p>

<h3 id="combo-squatting">Combo squatting</h3>
<p>Attackers can register domains with a trusted site’s name in combination with
some other item.</p>

<p>For example, XYZ Fake Corp’s domain is <code class="highlighter-rouge">xyzcorp.com</code>. I can register
<code class="highlighter-rouge">it-xyzcorp.com</code> and impersonate the IT department in my phishing emails.</p>

<h2 id="using-facebooks-phishing-detection-tool">Using Facebook’s Phishing Detection Tool</h2>
<p>Now that we’ve seen what the tool is capable of detecting from the CT logs,
let’s look at how we can use their API to generate alerts for us in Microsoft Teams
or Slack. This post only has code for MS Teams webhooks, but the process is
very similar for Slack.</p>

<p><img src="/assets/images/certmon.png" alt="Phishing domain pipeline" /></p>

<h3 id="milestone-1-creating-the-webhook-facebook-app">Milestone 1: Creating the Webhook Facebook App</h3>
<ol>
  <li>Before using Facebook’s APIs, we’ll need a Facebook account. If you do not already
have one, you must create an account and log in to proceed.</li>
  <li>Head to <a href="https://developer.facebook.com/">Facebook’s developer site</a> and select
<code class="highlighter-rouge">My Apps</code> –&gt; <code class="highlighter-rouge">Add New App</code>. You’ll be prompted for App ID info including an app
name and contact email. Just fill these out with whatever seems right to you.
<img src="/assets/images/new_fb_app.png" alt="Creating a new Facebook app" /></li>
  <li>You’ll be redirected to the Facebook App dashboard. On the left side of the page,
click the + symbol by <code class="highlighter-rouge">Products</code> and scroll until you find the Webhooks. Select
<code class="highlighter-rouge">Set Up</code> to begin configuring our Webhook service.
<img src="/assets/images/create_webhook.png" alt="Selecting the webhook" /></li>
  <li>Click <code class="highlighter-rouge">Subscribe to this object</code>. You’ll be prompted for a Callback URL (ie.,
what Facebook will post alert information to) as well as a security token. Since
we don’t have this information now, let’s leave this page be and head to the next
milestone.</li>
</ol>

<h3 id="milestone-2-setting-up-our-api-gateway-and-lambda-function">Milestone 2: Setting up our API gateway and Lambda Function</h3>
<p>In case you’re unfamiliar with AWS Lambda functions, they are functions of code
that you write and place into Amazon’s cloud. You do not set up a VM/EC2 instance
to run your code in. Instead, there are hooks that call your code (for example,
an API endpoint being hit) and you are charged only for the time that your code
is actually running. This not only saves you money, but you have to manage no
infrastructure whatsoever.</p>

<ol>
  <li>Log into AWS with your account and search for Lambda. Hit “Create function” in the
Functions tab seen below.
<img src="/assets/images/aws_lambda.png" alt="Lambda function page" /></li>
  <li>On the Create Function page, give the function a name and choose your runtime
language. I’ll be using Python 3.7 in this post. I accept the default Permissions
for now.</li>
  <li>In the Designer section of your newly-created function’s dashboard, choose
API Gateway under Add triggers. A trigger is essentially an event that causes your
Lambda function code to run. In this case, we will set up an API such that
when the API endpoint is hit, our function consumes the request data from Facebook
and posts to a Teams webhook.</li>
  <li>If you scroll down a bit, you’ll see the Configure triggers section. Select
“Create a new API”. Under Security choose “open with API key.” Hit Add in the lower right corner,
followed by the orange Save button in the upper right hand corner of the page.
<img src="/assets/images/api-add.png" alt="Adding new API" /></li>
  <li>Click on the link to your API Gateway in the API Gateway panel, or click Services
and type API Gateway at the top of the page. We want to delete the ANY method for the gateway
which will accept any HTTP method.
<img src="/assets/images/api-del.png" alt="Deleting ANY method" /></li>
  <li>Next we will add GET and POST methods to our API gateway:
    <ul>
      <li>Under Actions, select Create Method and select “GET” from the dropdown.</li>
      <li>In the setup pane to the right, select Lambda Function for Integration type and check “Use Lambda Proxy integration” so we can receive the request details in our function.</li>
      <li>In the Lambda Function section, start typing the name of your new function and select it once it appears.</li>
      <li>Finally, hit the Save button in the pane.</li>
      <li>Repeat these steps for POST.</li>
    </ul>
  </li>
  <li>We need to deploy the API to use it. Select the name of your API, then hit
Actions –&gt; Deploy Api. You can select “default” stage and hit deploy, and you’ll
be redirected. Select the dropdown on default and click your API name.
Note the “Invoke URL” as we’ll use this in the next milestone.
<img src="/assets/images/deploy-api.png" alt="Deploying the API" /></li>
  <li>Head back to the Lamdba function via Services –&gt; Lambda dropdown in the upper
left corner. You should only see two listings in the API Gateway panel now, one for
GET and one for POST. If there are more, delete the extraneous ones.</li>
</ol>

<h3 id="milestone-3-writing-the-lambda-code">Milestone 3: Writing the Lambda code</h3>
<p>Our Lamdba function will take Facebook’s alert data from our API endpoints and
relay that information in a readable context to Microsoft Teams. We’ll use
Python in this post, but Javascript or any other supported language by Lambda
will work just as well.</p>

<p>The <a href="https://github.com/b1tst0rm/certguard/blob/master/certguard.py">full code is available here</a>, so feel free to copy and paste that into your function editor now, and I’ll
walk you through it step-by-step.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">logging</span>  <span class="c"># for CloudWatch logs</span>
<span class="kn">from</span> <span class="nn">botocore.vendored</span> <span class="kn">import</span> <span class="n">requests</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

<span class="n">TEAMS_ENDPOINT</span> <span class="o">=</span> <span class="s">"SET THIS (ie., https://outlook.office.com/webhook/...)"</span>
<span class="n">SECURITY_TOKEN</span> <span class="o">=</span> <span class="s">"SET THIS"</span>
</code></pre></div></div>
<p>This first chunk of code imports some necessary modules. We’ll set up logging
using AWS’s CloudWatch for monitoring and debugging purposes later.
You’ll need to set <code class="highlighter-rouge">TEAMS_ENDPOINT</code> to your Microsoft Teams Webhook URL.
Let’s fetch that now. Head to your Microsoft Teams application (web or desktop).</p>

<p><img src="/assets/images/connectors.png" alt="Connector in Teams" /></p>

<ol>
  <li>Select or create a channel that you’d like to use for the alerts to be posted
in. I chose General.</li>
  <li>Next, select the menu to the right of the channel
and click “Connectors”.</li>
  <li>Search for “webhook” and click “Configure” on the Incoming Webhook option.</li>
  <li>On the next screen, give your webhook a name and optionally a profile
picture. I named mine “certmon-test”.</li>
  <li>The same dialog box will refresh and you’ll see a box with a URL in it.
Copy that URL, it’s what we need to set TEAMS_ENDPOINT to in our Lamdba code.</li>
  <li>Now you can hit “Done” on the Teams dialog box.</li>
</ol>

<p>Set the <code class="highlighter-rouge">SECURITY_TOKEN</code> in your Lambda function code to (ideally) a
randomly-generated string of any size. You’ll configure your Facebook app
later with this access token.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEAMS_CARD</span> <span class="o">=</span> <span class="s">"""
{
    "@context": "https://schema.org/extensions",
    "@type": "MessageCard",
    "themeColor": "FF0000",
    "title": "Alert: Potentially Malicious Domain Discovered!",
    "text": "Facebook Certificate Transparency Monitoring System has detected a new SSL certificate issued for what looks to be an illegitimate domain similar to ",
    "sections": [
        {
            "startGroup": true,
            "title": "DOMAIN: **mal.blah.d.com**",
            "facts": [
                {
                    "name": "Date submitted:",
                    "value": "06/27/2017, 2:44 PM"
                }
            ]
        },
        {
            "startGroup": true,
            "potentialAction": [
                {
                    "@type": "OpenUri",
                    "name": "Learn more about Facebook Certificate Transparency",
                    "targets": [
                        {
                            "os": "default",
                            "uri": "https://developers.facebook.com/docs/certificate-transparency/"
                        }
                    ]
                }
            ]
        }
    ]
}
"""</span>
</code></pre></div></div>
<p>Above is JSON output representing the design and layout of how the alert
will look in Microsoft Teams. Feel free to edit this by using Microsoft’s
<a href="https://messagecardplayground.azurewebsites.net/">online editor playground</a>
and <a href="https://docs.microsoft.com/en-us/outlook/actionable-messages/send-via-connectors">documentation</a>,
but it should work out-of-the-box for you.</p>

<p>Next I configure a logger for AWS Cloudwatch. This isn’t neccessary, but if
you’d like to log Lambda usage for debugging purposes it is very helpful:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">()</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
</code></pre></div></div>

<p>Now for the juicy part: the actual “Lamdba function” that is called when
our API gets data from Facebook. The request data is stored in a variable
called <code class="highlighter-rouge">event</code> containing JSON data. First I define the function and perform
some logging:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">lambda_handler</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'got event {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
</code></pre></div></div>

<p>If you dig into <a href="https://developers.facebook.com/docs/certificate-transparency-api/">Facebook’s API docs</a>, it states that the API periodically sends
a GET request to verify our endpoint is up and working. We check their
<code class="highlighter-rouge">verify_token</code> value against our <code class="highlighter-rouge">SECURITY_TOKEN</code> and if they are the same,
we respond with a 200, letting Facebook know we are alive and ready to
receive info.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="s">'httpMethod'</span><span class="p">]</span> <span class="o">==</span> <span class="s">'GET'</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="s">'queryStringParameters'</span><span class="p">][</span><span class="s">'hub.verify_token'</span><span class="p">]</span> <span class="o">==</span>
                <span class="n">SECURITY_TOKEN</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'API GET call successful'</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s">'statusCode'</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
                <span class="s">'body'</span><span class="p">:</span> <span class="n">event</span><span class="p">[</span><span class="s">'queryStringParameters'</span><span class="p">][</span><span class="s">'hub.challenge'</span><span class="p">]</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">'API GET call failed'</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s">'statusCode'</span><span class="p">:</span> <span class="mi">400</span><span class="p">,</span>
                <span class="s">'body'</span><span class="p">:</span> <span class="s">'Something went wrong'</span>
            <span class="p">}</span>	
</code></pre></div></div>

<p>The only other type of request we should receive from Facebook is a <code class="highlighter-rouge">POST</code>.
The <code class="highlighter-rouge">POST</code> requests are Facebook sending us alert info. Below we handle this
by extracting the alert info and sending it to another function to
create a new MS Teams message for each phishing domain. Finally, we respond
to Facebook with a 200.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">elif</span> <span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="s">'httpMethod'</span><span class="p">]</span> <span class="o">==</span> <span class="s">'POST'</span><span class="p">):</span>
        <span class="c"># Fetch the JSON body from Facebook</span>
        <span class="n">body</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="s">'body'</span><span class="p">])</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># If more than one alert in the payload</span>
            <span class="n">changes_value</span> <span class="o">=</span> <span class="n">body</span><span class="p">[</span><span class="s">'entry'</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">'changes'</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">'value'</span><span class="p">]</span>
            <span class="n">domains</span> <span class="o">=</span> <span class="n">changes_value</span><span class="p">[</span><span class="s">'phishing_domains'</span><span class="p">]</span>
            <span class="n">original_domain</span> <span class="o">=</span> <span class="n">changes_value</span><span class="p">[</span><span class="s">'phished_domain'</span><span class="p">]</span>
            
            <span class="k">for</span> <span class="n">domain</span> <span class="ow">in</span> <span class="n">domains</span><span class="p">:</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">utcfromtimestamp</span><span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">body</span><span class="p">[</span><span class="s">'entry'</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">'time'</span><span class="p">])</span>
                <span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s">'</span><span class="si">%</span><span class="s">Y-</span><span class="si">%</span><span class="s">m-</span><span class="si">%</span><span class="s">d </span><span class="si">%</span><span class="s">H:</span><span class="si">%</span><span class="s">M:</span><span class="si">%</span><span class="s">S'</span><span class="p">)</span> <span class="o">+</span> <span class="s">" UTC"</span>
                <span class="n">relay_alert</span><span class="p">(</span><span class="n">original_domain</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>

        <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
            <span class="c"># If just one alert in the body</span>
            <span class="n">mal_domain</span> <span class="o">=</span> <span class="n">body</span><span class="p">[</span><span class="s">'value'</span><span class="p">][</span><span class="s">'phishing_domains'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">original_domain</span> <span class="o">=</span> <span class="n">body</span><span class="p">[</span><span class="s">'value'</span><span class="p">][</span><span class="s">'phished_domain'</span><span class="p">]</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">utcfromtimestamp</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">body</span><span class="p">[</span><span class="s">'time'</span><span class="p">])</span>
            <span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s">'</span><span class="si">%</span><span class="s">Y-</span><span class="si">%</span><span class="s">m-</span><span class="si">%</span><span class="s">d </span><span class="si">%</span><span class="s">H:</span><span class="si">%</span><span class="s">M:</span><span class="si">%</span><span class="s">S'</span><span class="p">)</span> <span class="o">+</span> <span class="s">" UTC"</span>
            <span class="n">relay_alert</span><span class="p">(</span><span class="n">original_domain</span><span class="p">,</span> <span class="n">mal_domain</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s">'statusCode'</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
            <span class="s">'body'</span><span class="p">:</span> <span class="s">'success'</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>If we get any other type of  HTTP request, we log it and respond
with a 400:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">'Invalid HTTP method hit'</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s">'statusCode'</span><span class="p">:</span> <span class="mi">400</span><span class="p">,</span>
            <span class="s">'body'</span><span class="p">:</span> <span class="s">'Invalid HTTP Method'</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>The last piece of our code is the function to generate an alert in MS Teams.
Here we load the JSON for the Card, change the values with our new intel,
and fire off a POST request to the Teams endpoint configured earlier:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">relay_alert</span><span class="p">(</span><span class="n">orig_domain</span><span class="p">,</span> <span class="n">mal_domain</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
    <span class="s">"""
    Given the original domain, malicious/phishing domain, and time of
    occurrence, sends an alert to Teams endpoint using a formatted Card.
    """</span>
    <span class="n">card_to_send</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">TEAMS_CARD</span><span class="p">)</span>
    <span class="n">card_to_send</span><span class="p">[</span><span class="s">'text'</span><span class="p">]</span> <span class="o">+=</span> <span class="s">'**'</span> <span class="o">+</span> <span class="n">orig_domain</span> <span class="o">+</span> <span class="s">'**'</span>
    <span class="n">card_to_send</span><span class="p">[</span><span class="s">'sections'</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">'title'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'**'</span> <span class="o">+</span> <span class="n">mal_domain</span> <span class="o">+</span> <span class="s">'**'</span>
    <span class="n">card_to_send</span><span class="p">[</span><span class="s">'sections'</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">'facts'</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">'value'</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
    <span class="n">json_teams_str</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">card_to_send</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">TEAMS_ENDPOINT</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">json_teams_str</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="milestone-4-final-facebook-config">Milestone 4: Final Facebook Config</h3>
<p>We now have our Lambda function ready and API endpoints to feed into our
Facebook app.</p>

<ol>
  <li>Open up <code class="highlighter-rouge">https://developers.facebook.com/</code> and head to your app we made earlier.</li>
  <li>Under Products –&gt; Webhooks, select “Subscribe to this object” with “Certificate Transparency”
being selected. A popup dialog will appear. For <code class="highlighter-rouge">Callback URL</code> input your Invoke URL 
from AWS. It should look something like:
<code class="highlighter-rouge">https://XYZ.execute-api.us-XYZ-N.amazonaws.com/default/YOURAPINAMEHERE</code>
For <code class="highlighter-rouge">Verify Token</code>, paste in the value of <code class="highlighter-rouge">SECURITY_TOKEN</code> variable in your Lambda Function.
Clicking Verify and Save will fire off a test to ensure the endpoint is functioning.
If everything goes well, the dialog box will close without error.</li>
  <li>Under phishing hit Subscribe. The Lambda code is written to work with API v3.3.
<img src="/assets/images/phish-sub.png" alt="Sub to phishing" /></li>
  <li>In order for Facebook to send us alerts, we must make our app live. Click the
slider in the upper-right-hand corner. If you are prompted to add a privacy policy
URL, add one in and try again. Once live the slider will turn green like below.
<img src="/assets/images/go-live.png" alt="Live application" /></li>
  <li>Now hit “Test” by phishing. Facebook will send a test alert and you should
see a new message in Teams.
<img src="/assets/images/teams-test.png" alt="Test in Microsoft Teams" /></li>
</ol>

<h3 id="thats-it">That’s it.</h3>

<p>Organizations and teams across the world can use this free API service
to monitor their domain(s) and be made aware when certificates with domains
suspiciously similar to theirs are generated. This may help you get a head
start on response to a malicious phishing campaign, especially nasty
spearheaded ones.</p>

<p>Github Repo: <a href="https://github.com/b1tst0rm/certguard">https://github.com/b1tst0rm/certguard</a></p>

<p>Questions? Comment below!</p>

<p>~ b1tst0rm (Daniel)</p>

      
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_config = function () {
      this.page.url = 'https://b1tst0rm.net//2019/06/11/certguard.html';
      this.page.identifier = '/2019/06/11/certguard.html';
    };

    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://b1tst0rm.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>
    Please enable JavaScript to view <a href="https://disqus.com/?ref_noscript">comments.</a>
</noscript>



      <footer class="site-footer">
          <span><a href="http://github.com/b1tst0rm">Github</a></span>
          <span><a href="https://www.linkedin.com/in/daniellimanowski/">LinkedIn</a></span>
          <span><a href="https://twitter.com/b1tst0rm">Twitter</a></span>
      </footer>
    </main>
  </body>
</html>
